# ロック競合による性能劣化

## 概要

複数のロックを必要とするテスト（またはスレッド）が、一部のロックを保持したまま他のロックの取得を待機することで、後続のテストがカスケード的にブロックされ、全体の実行時間が大幅に増加する現象。

## 発生条件

1. テストAがロックXを保持した状態でロックYの取得を待機する
2. テストBがロックXを必要とするが、テストAが保持しているためブロックされる
3. ロックYの保持者が長時間ロックを解放しない

## デッドロックとの違い

| 項目 | デッドロック | ロック競合による性能劣化 |
|------|-------------|------------------------|
| 循環待機 | あり | なし |
| 結果 | 永久にブロック | 長時間の遅延後に完了 |
| 検出 | 比較的容易 | 気づきにくい |

## 具体例

```
Test1: Lock B（排他ロック）を保持し、長時間の処理を実行中（35分）

Test2: Lock A（共有ロック）を取得
       → Lock B（排他ロック）を待機（Test1 が保持中のため）
       → Lock A を保持したまま35分待機

Test3: Lock A（排他ロック）を待機
       → Test2 が Lock A を保持中のためブロック

Test4: Lock A（排他ロック）を待機
       → Test3 の後ろで待機

Test5: Lock A（共有ロック）を待機
       → Test3（排他ロック待ち）がいるためブロック（Writer Starvation 防止のため）
```

**結果**: Test1 の35分の処理が、Test2, Test3, Test4, Test5 全てに波及し、全体の実行時間が大幅に増加。

**根本原因**: Test2 が Lock A を保持したまま Lock B を待機したこと（Hold and Wait）。

## 解決策

必要なロックを全て同時に取得するか、どれも取得しない方式（Atomic Lock Acquisition）を採用する。これにより、ロックを保持したまま他のロックを待機する状態（Hold and Wait）を排除する。

### 解決前（Hold and Wait が発生しうる）

```go
lock.A(t)  // Lock A を取得
lock.B(t)  // Lock A を保持したまま Lock B を待機
```

### 解決後（Hold and Wait を排除）

```go
ml := lock.NewMultiLock(t,
    lock.Shared("A"),
    lock.Exclusive("B"),
)
ml.AcquireAll(t)  // 両方取得可能になるまで、どちらも保持しない
```

### 解決後の動作

Atomic Lock Acquisition により、Test2 は Lock A と Lock B の両方が取得可能になるまで待機し、どちらのロックも保持しない。これにより、Lock A のみを必要とする Test3, Test4, Test5 は Test1 の処理完了を待たずに実行できる。

#### 解決前のタイムライン

```
時間    0分                    35分              40分  41分  42分
        |------------------------|------------------|-----|-----|
Test1:  |====== Lock B 保持 ======|
Test2:  |= Lock A 保持 =|---Lock B 待機(35分)---|==処理==|
Test3:  |------Lock A 待機(35分)----------------|==処理==|
Test4:  |------Lock A 待機(36分)-------------------------|==処理==|
Test5:  |------Lock A 待機(37分)------------------------------|...

全体の実行時間: 42分以上（カスケード的に遅延が波及）
```

#### 解決後のタイムライン

```
時間    0分        5分   6分   7分             35分
        |----------|-----|-----|---------------|
Test1:  |====== Lock B 保持 ==================|
Test2:  |--Lock A+B 待機（どちらも保持しない）--|==処理==|
Test3:  |==処理==|                              （Lock A のみ必要、即座に実行可能）
Test4:  |........|==処理==|                     （Test3 完了後に実行）
Test5:  |==処理==|                              （Lock A 共有ロック、Test3 と並行実行可能）

全体の実行時間: 約36分（Test3, Test4, Test5 が先に完了）
```

#### ポイント

1. **Test2 がロックを保持しない**: Lock B が取得できない間、Lock A も取得しないため、他のテストをブロックしない
2. **Test3, Test4, Test5 が先行実行**: Lock A のみを必要とするテストは、Test1 の完了を待たずに実行できる
3. **全体の実行時間短縮**: カスケード的な遅延がなくなり、並行実行の効率が向上する

## 関連概念

- **Hold and Wait**: デッドロックの4条件（Coffman条件）の1つ。ロックを保持したまま他のロックを待機する状態。
- **Two-Phase Locking (2PL)**: データベース分野における同様の問題に対する解決策。
- **Atomic Lock Acquisition**: 必要なロックを全て同時に取得するか、どれも取得しない方式。
