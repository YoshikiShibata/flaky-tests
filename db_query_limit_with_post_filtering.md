# DBクエリの LIMIT と後フィルタリングによるフレーキーテスト

## はじめに

DBクエリで `LIMIT` を指定して取得した結果に対して、
アプリケーション側で追加のフィルタリングを行うパターンは珍しくありません。
しかし、`LIMIT` の値が小さすぎると、フィルタ後に対象レコードが0件になり得るという
潜在的なバグを生みます。

本記事では、このパターンが原因でフレーキーテストが発生した実例と、
一般的な対策を紹介します。

## 問題の本質

以下の2段階処理を行うクエリパターンで問題が発生します：

1. **DBクエリ**: カテゴリの区別なくレコードを `ORDER BY CreateTime DESC LIMIT N` で取得
2. **アプリケーション側フィルタ**: 取得したレコードをカテゴリでフィルタリング

`LIMIT N` が小さいと、特定のカテゴリのレコードが多い場合に
他のカテゴリのレコードが `LIMIT` に収まらず、フィルタ後に0件になります。

```
DB内のレコード（CreateTime DESC順）:
  1. カテゴリA（最新）
  2. カテゴリA
  3. カテゴリB   ← LIMIT=2 だとここに到達しない
  4. カテゴリB

LIMIT=2 で取得 → [カテゴリA, カテゴリA]
カテゴリBでフィルタ → [] （0件）
```

## 実例

### 背景

あるタスク達成判定の処理で、ユーザーの進捗レコードを取得する関数がありました。
進捗レコードにはカテゴリA・カテゴリBの2種類があり、
同一テーブルに格納されています。

```sql
SELECT *
FROM Progresses
WHERE UserID = @userID
  AND CreateTime >= @createTime
ORDER BY CreateTime DESC
LIMIT @limit
```

このクエリは **カテゴリでフィルタしません**。
取得後にアプリケーション側で、関連テーブルを参照してカテゴリによるフィルタリングを行っていました。

```go
// limit=2 で両方のカテゴリを取得しようとしていた
const limit = 2
progresses, _ := repo.ListProgressesByUserIDAndCategoryAndCreateTime(
    ctx, userID, category, task.CreateTime, limit,
)

if len(progresses) == 0 {
    return ErrNoProgresses // このエラーは呼び出し元で握り潰される
}
```

### 問題の発生メカニズム

1. ユーザーがカテゴリAの操作を3回、カテゴリBの操作を2回実行
2. `ORDER BY CreateTime DESC LIMIT 2` で最新2件を取得
3. 最新2件がカテゴリAのレコードだった場合、カテゴリBでフィルタすると0件
4. `ErrNoProgresses` が返されるが、**呼び出し元で握り潰される**
5. タスクカウントがインクリメントされないまま処理が正常終了
6. 後続の処理で `count < requiredCount` となり失敗

### なぜフレーキーか

異なるカテゴリのレコードが同じ `CreateTime` を持つ場合、
`ORDER BY CreateTime DESC` だけでは順序が一意に定まりません。
同一時刻のレコードの返却順序はDBの内部状態に依存するため、
実行のたびに結果が変わります。

- カテゴリBのレコードが先に返る → **PASS**
- カテゴリAのレコードが先に返る → **FAIL**

### 補足

この問題はテスト固有のものではなく、本番環境でも発生し得る問題でした。
新しく追加されたテストがこの潜在的なバグを顕在化させたケースです。

また、同じコードベース内の別の関数では既にこの問題が認識されており、
コメント付きで十分大きな `LIMIT` が設定されていました。
同じパターンの修正が他の箇所に適用されていないケースは珍しくありません。

## 問題を深刻にする要因: エラーの握り潰し

このバグが発見しにくかった理由は、フィルタ後に0件になったときのエラーが
**握り潰されていた**ことにあります。

```go
if err := transaction.Run(func() error {
    // ... 0件の場合 ErrNoProgresses を返す
}); err != nil {
    if errors.Is(err, ErrNoProgresses) {
        return nil  // エラーを握り潰す
    }
    return err
}
```

外部からは処理が成功したように見えるため、問題の特定が困難でした。

## 一般的な対策

### 1. DB側でフィルタする（推奨）

可能であれば、フィルタ条件をSQLクエリに含めて、
アプリケーション側の後フィルタリングを避けます。

```sql
-- 改善: JOINでカテゴリを絞り込む
SELECT p.*
FROM Progresses p
JOIN Categories c ON p.CategoryID = c.ID
WHERE p.UserID = @userID
  AND p.CreateTime >= @createTime
  AND c.Type = @categoryType
ORDER BY p.CreateTime DESC
LIMIT @limit
```

### 2. LIMIT を十分大きくする

DB側でフィルタできない場合は、`LIMIT` を十分大きな値に設定して、
全てのカテゴリのレコードが含まれるようにします。
ただし、これはワークアラウンドであり、理論上は同じ問題が再発する可能性があります。

### 3. エラーを握り潰さない

「0件だった」という状態が本来起こるべきでない場合は、
エラーを握り潰さずに上位に伝播させるべきです。
握り潰しにより処理が成功したように見えると、問題の発見が大幅に遅れます。

## チェックリスト

以下の条件が揃うとこのパターンのバグが潜在している可能性があります：

- [ ] DBクエリに `LIMIT` が設定されている
- [ ] 取得後にアプリケーション側でフィルタリングしている
- [ ] フィルタ後に0件になったときのエラーが握り潰されている
- [ ] `LIMIT` の値がフィルタ前のカテゴリの種類数・件数に対して十分でない

## 教訓

1. **`LIMIT` + 後フィルタリングは本質的に危険** — DB側でフィルタできないか検討する
2. **エラーの握り潰しは問題の発見を遅らせる** — 想定外の状態は明示的にエラーにする
3. **同じコードベース内に修正済みの箇所がないか確認する** — 同じパターンの問題が別の場所に残っていることがある
4. **新しいテストが潜在的なバグを顕在化させることがある** — テスト追加はプロダクションコードの品質向上にも寄与する
