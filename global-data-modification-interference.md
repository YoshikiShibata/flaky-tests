# 全データ更新ジョブによるテスト間干渉

## 概要

テーブル内の全行を処理するジョブのテストと、特定のデータをセットアップして検証するテストが並列実行された際に発生するFlaky test。

## 症状

- 特定のテストを単独で実行すると常に成功する
- 全E2Eテストを並列実行すると、特定のテストがランダムに失敗する
- セットアップしたデータが、テスト実行中に別の値に上書きされている

## 根本原因

### 問題のあるテスト構成

1. **ジョブテストA**: テーブルXの全行を処理し、`InsertOrUpdate` で更新する
2. **機能テストB**: テーブルXに特定のテストデータをセットアップし、そのデータに依存した検証を行う

### 発生メカニズム

1. 機能テストBがテーブルXに期待値（例: Score = 100〜1100）を INSERT
2. ジョブテストAが並列で実行され、テーブルXの全行に対して `InsertOrUpdate` を実行
3. 機能テストBのテストデータが上書きされる（例: Score = 0）
4. 機能テストBの検証が失敗

## 解決策

### ロックによるテスト間排他制御

テストフレームワークのロック機構を使用して、競合するテスト間の同時実行を防ぐ。

#### ロックの種類

- **Exclusive（排他ロック）**: 全行を更新するジョブテストに使用
- **Shared（共有ロック）**: 一意のデータのみを INSERT するテストに使用

#### 適用ルール

| テストの特性 | ロックの種類 |
|------------|------------|
| テーブルの全行を `InsertOrUpdate` で更新 | Exclusive |
| 一意のキーで自身のデータのみを INSERT | Shared |

#### Shared ロックを使用できる条件

以下の条件を全て満たす場合、Shared ロックを使用できる：

1. テスト内で作成した一意のキー（例: UUID）のみを INSERT する
2. 既存の行を更新・削除しない
3. 他のテストが作成したデータに依存しない

Shared ロック同士は並列実行可能だが、Exclusive ロックとは排他になるため、全行更新ジョブとの同時実行が防止される。

## 教訓

1. **全データを処理するジョブ**のテストは、他のテストと干渉する可能性が高い
2. `InsertOrUpdate` は便利だが、テスト環境では意図しないデータ上書きを引き起こす
3. テストの失敗原因を調査する際は、**並列実行される他のテスト**の影響も考慮する
4. 単体で成功するテストが全体実行で失敗する場合、テスト間の分離問題を疑う
